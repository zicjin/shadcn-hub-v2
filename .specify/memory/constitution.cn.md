<!--
Sync Impact Report
版本变更: NEW → 1.0.0
新增章节:
  - 核心原则 (基于《程序员修炼之道》的7个原则)
  - 开发工作流
  - 质量标准
  - 治理
需要更新的模板: ⚠ 待定
  - .specify/templates/plan-template.md (Constitution Check 部分需要对齐)
  - .specify/templates/spec-template.md (需求与原则对齐)
  - .specify/templates/tasks-template.md (TDD 强制执行对齐)
后续待办事项:
  - RATIFICATION_DATE: 正式采用时设置
-->

# Spec App 章程

## 核心原则

### I. DRY (不要重复自己)
系统中的每一条知识都必须有一个单一、明确、权威的表述。重复是导致不一致和增加维护负担的根源。将通用功能提取到可重用的库、函数或配置中。当重复看似必要时，首先要寻找抽象的机会。

### II. 正交性与解耦
组件的设计必须是独立和可互换的。对一个模块的更改不应波及系统中不相关的部分。通过清晰的接口、依赖注入和避免全局状态来实现这一点。每个组件都应该做好一件事，并对其他组件的了解降到最低。

### III. 示踪子弹与原型设计
尽早构建端到端的功能以验证方法。从一个简单的、可行的实现开始，该实现能够贯穿架构的所有层次。这能及早发现集成问题，并为增量增强提供支架。用户能更快地看到进展，并能对实际可用的软件提供反馈。

### IV. 可逆性与灵活性
避免陷入不可逆的决策。设计系统时要假定需求、技术和环境都会发生变化。使用配置而非硬编码，使用接口而非具体实现，并保持业务逻辑和基础设施之间的清晰分离。关键决策应该易于逆转。

### V. 测试驱动开发
在实现之前编写测试。每个功能都必须有自动化测试来定义其预期行为。严格遵循“红-绿-重构”循环：编写一个失败的测试，实现刚好能通过测试的代码，然后重构以提高清晰度。测试集文档、规范和安全网于一体。

### VI. 足够好的软件
要懂得适可而止。软件必须对用户、未来的维护者以及你自己来说足够好。要清楚何时你正在用复杂性换取递减的回报。尽早交付可用的软件，并根据实际使用情况进行迭代，而不是基于想象中的完美。

### VII. 破窗理论
绝不留下“破窗”（糟糕的设计、错误的决策、劣质的代码）不予修复。一个投机取巧的修改会引来另一个，很快代码库的熵就会变得无法管理。发现问题时就立即修复。如果无法立即进行适当的修复，至少要用一个 TODO 和一个计划来承认它。

## 开发工作流

### 沟通与文档
- 使用能揭示意图的有意义的名称
- 记录原因，而不是内容（代码展示了内容）
- 保持文档与代码紧密相关并及时更新
- 为领域术语维护一个项目词汇表
- 与利益相关者进行积极沟通

### 估算与规划
- 以范围而非单一数值进行估算
- 将大任务分解为更小的、可度量的部分
- 随代码迭代进度计划
- 为决策和学习保留项目日志
- 通过原型验证高风险假设

### 调试与问题解决
- 不要恐慌 - 仔细阅读错误信息
- 在尝试修复前可靠地重现问题
- 修复根本原因，而不是表面症状
- 为每个修复的 bug 添加回归测试

## 质量标准

### 代码质量门禁
- 所有代码在合并前必须通过自动化测试
- 代码覆盖率不得因新变更而下降
- 静态分析工具必须无错误运行
- 性能基准必须保持在可接受范围内
- 依赖项必须通过安全扫描

### 设计质量
- 最小化模块间的耦合（目标是每个模块少于3个依赖）
- 最大化模块内的内聚
- 在适用的地方遵循 SOLID 原则
- 契约式设计 - 定义前置条件、后置条件和不变量
- 适当而非普遍地使用设计模式

### 用户体验焦点
- 错误信息必须是可操作且有帮助的
- 功能无需文档即可被发现
- 性能必须是可感知的（UI 响应 <200ms）
- 可访问性必须是内置的，而不是外加的
- 默认保障隐私和安全

## 治理

### 修订流程
- 破坏性变更需要迁移计划
- 根据语义化版本控制提升版本号
- 修订必须传播到所有依赖的模板

### 合规与审查
- 所有代码审查必须验证是否遵守原则
- 例外情况必须附有理由说明
- 本章程优先于任何冲突的实践

### 持续改进
- 维护一份“经验教训”日志
- 定期进行回顾以识别流程改进点
- 鼓励在指定的沙盒区域进行实验
- 投资于能自动强制执行原则的工具

**版本**: 1.0.0 | **批准日期**: TODO(RATIFICATION_DATE): 正式采用时设置 | **最后修订**: 2025-09-23
